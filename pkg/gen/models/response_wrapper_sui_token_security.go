// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ResponseWrapperSuiTokenSecurity ResponseWrapperSuiTokenSecurity
//
// swagger:model ResponseWrapperSuiTokenSecurity
type ResponseWrapperSuiTokenSecurity struct {

	// Code 1：Success
	Code int32 `json:"code,omitempty"`

	// Response message
	Message string `json:"message,omitempty"`

	// Response result
	Result map[string]ResponseWrapperSuiTokenSecurityResultAnon `json:"result,omitempty"`
}

// Validate validates this response wrapper sui token security
func (m *ResponseWrapperSuiTokenSecurity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSuiTokenSecurity) validateResult(formats strfmt.Registry) error {

	if swag.IsZero(m.Result) { // not required
		return nil
	}

	for k := range m.Result {

		if swag.IsZero(m.Result[k]) { // not required
			continue
		}
		if val, ok := m.Result[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSuiTokenSecurity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSuiTokenSecurity) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSuiTokenSecurity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSuiTokenSecurityResultAnon key is contract address
//
// swagger:model ResponseWrapperSuiTokenSecurityResultAnon
type ResponseWrapperSuiTokenSecurityResultAnon struct {

	// blacklist
	Blacklist *ResponseWrapperSuiTokenSecurityResultAnonBlacklist `json:"blacklist,omitempty"`

	// contract upgradeable
	ContractUpgradeable *ResponseWrapperSuiTokenSecurityResultAnonContractUpgradeable `json:"contract_upgradeable,omitempty"`

	// Creator of the token.
	Creator string `json:"creator,omitempty"`

	// Decimals of the token.
	Decimals int32 `json:"decimals,omitempty"`

	// metadata modifiable
	MetadataModifiable *ResponseWrapperSuiTokenSecurityResultAnonMetadataModifiable `json:"metadata_modifiable,omitempty"`

	// mintable
	Mintable *ResponseWrapperSuiTokenSecurityResultAnonMintable `json:"mintable,omitempty"`

	// Name of the token.
	Name string `json:"name,omitempty"`

	// Symbol of the token.
	Symbol string `json:"symbol,omitempty"`

	// Total supply of the token.
	TotalSupply string `json:"total_supply,omitempty"`

	// If the token is a famous and trustworthy one. "1" means yes.(Notice: This field is intended to identify well-known and reputable tokens. Trusted tokens with special functions (such as the mintable function in USDC) are generally not considered risk items. Please note that a value other than “1” does not indicate that the token is untrustworthy. We recommend properly evaluating and handling tokens with values other than “1” to avoid unnecessary disputes.
	// )
	TrustedToken string `json:"trusted_token,omitempty"`
}

// Validate validates this response wrapper sui token security result anon
func (m *ResponseWrapperSuiTokenSecurityResultAnon) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlacklist(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContractUpgradeable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadataModifiable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMintable(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSuiTokenSecurityResultAnon) validateBlacklist(formats strfmt.Registry) error {

	if swag.IsZero(m.Blacklist) { // not required
		return nil
	}

	if m.Blacklist != nil {
		if err := m.Blacklist.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("blacklist")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSuiTokenSecurityResultAnon) validateContractUpgradeable(formats strfmt.Registry) error {

	if swag.IsZero(m.ContractUpgradeable) { // not required
		return nil
	}

	if m.ContractUpgradeable != nil {
		if err := m.ContractUpgradeable.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contract_upgradeable")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSuiTokenSecurityResultAnon) validateMetadataModifiable(formats strfmt.Registry) error {

	if swag.IsZero(m.MetadataModifiable) { // not required
		return nil
	}

	if m.MetadataModifiable != nil {
		if err := m.MetadataModifiable.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata_modifiable")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSuiTokenSecurityResultAnon) validateMintable(formats strfmt.Registry) error {

	if swag.IsZero(m.Mintable) { // not required
		return nil
	}

	if m.Mintable != nil {
		if err := m.Mintable.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mintable")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSuiTokenSecurityResultAnon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSuiTokenSecurityResultAnon) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSuiTokenSecurityResultAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSuiTokenSecurityResultAnonBlacklist Whether the developer can block any other users from trading.
//
// swagger:model ResponseWrapperSuiTokenSecurityResultAnonBlacklist
type ResponseWrapperSuiTokenSecurityResultAnonBlacklist struct {

	// The owner cap of the function.
	// This field can have three possible values:
	// A. A specific address indicates the address that can currently operate this function.
	// B.'Shared' means any address can operate this function.
	// C.'Immutable' means this function can no longer be invoked.
	CapOwner string `json:"cap_owner,omitempty"`

	// Status indicator, where "1" means the funtcion is available.
	Value string `json:"value,omitempty"`
}

// Validate validates this response wrapper sui token security result anon blacklist
func (m *ResponseWrapperSuiTokenSecurityResultAnonBlacklist) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSuiTokenSecurityResultAnonBlacklist) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSuiTokenSecurityResultAnonBlacklist) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSuiTokenSecurityResultAnonBlacklist
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSuiTokenSecurityResultAnonContractUpgradeable Whetherthe token contract upgradebale. If the contract is upgradable, developers can arbitrarily modify its functions.
// This field follows the same rules as the other similar fields.
//
// swagger:model ResponseWrapperSuiTokenSecurityResultAnonContractUpgradeable
type ResponseWrapperSuiTokenSecurityResultAnonContractUpgradeable struct {

	// The owner cap of the function.
	// This field can have three possible values:
	// A. A specific address indicates the address that can currently operate this function.
	// B.'Shared' means any address can operate this function.
	// C.'Immutable' means this function can no longer be invoked.
	CapOwner string `json:"cap_owner,omitempty"`

	// Status indicator, where "1" means the funtcion is available.
	Value string `json:"value,omitempty"`
}

// Validate validates this response wrapper sui token security result anon contract upgradeable
func (m *ResponseWrapperSuiTokenSecurityResultAnonContractUpgradeable) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSuiTokenSecurityResultAnonContractUpgradeable) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSuiTokenSecurityResultAnonContractUpgradeable) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSuiTokenSecurityResultAnonContractUpgradeable
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSuiTokenSecurityResultAnonMetadataModifiable Whether the metadata is mutable.
//
// swagger:model ResponseWrapperSuiTokenSecurityResultAnonMetadataModifiable
type ResponseWrapperSuiTokenSecurityResultAnonMetadataModifiable struct {

	// The owner cap of the function.
	// This field can have three possible values:
	// A. A specific address indicates the address that can currently operate this function.
	// B.'Shared' means any address can operate this function.
	// C.'Immutable' means this function can no longer be invoked.
	CapOwner string `json:"cap_owner,omitempty"`

	// Status indicator, where "1" means the funtcion is available.
	Value string `json:"value,omitempty"`
}

// Validate validates this response wrapper sui token security result anon metadata modifiable
func (m *ResponseWrapperSuiTokenSecurityResultAnonMetadataModifiable) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSuiTokenSecurityResultAnonMetadataModifiable) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSuiTokenSecurityResultAnonMetadataModifiable) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSuiTokenSecurityResultAnonMetadataModifiable
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSuiTokenSecurityResultAnonMintable Whether the token is mintable.
//
// swagger:model ResponseWrapperSuiTokenSecurityResultAnonMintable
type ResponseWrapperSuiTokenSecurityResultAnonMintable struct {

	// The owner cap of the function.
	// This field can have three possible values:
	// A. A specific address indicates the address that can currently operate this function.
	// B.'Shared' means any address can operate this function.
	// C.'Immutable' means this function can no longer be invoked.
	CapOwner string `json:"cap_owner,omitempty"`

	// Status indicator, where "1" means the funtcion is available.
	Value string `json:"value,omitempty"`
}

// Validate validates this response wrapper sui token security result anon mintable
func (m *ResponseWrapperSuiTokenSecurityResultAnonMintable) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSuiTokenSecurityResultAnonMintable) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSuiTokenSecurityResultAnonMintable) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSuiTokenSecurityResultAnonMintable
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
