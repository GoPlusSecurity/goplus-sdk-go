// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ResponseWrapperSolanaTokenSecurity ResponseWrapperSolanaTokenSecurity
//
// swagger:model ResponseWrapperSolanaTokenSecurity
type ResponseWrapperSolanaTokenSecurity struct {

	// Code 1ï¼šSuccess
	Code int32 `json:"code,omitempty"`

	// Response message
	Message string `json:"message,omitempty"`

	// Response result
	Result map[string]ResponseWrapperSolanaTokenSecurityResultAnon `json:"result,omitempty"`
}

// Validate validates this response wrapper solana token security
func (m *ResponseWrapperSolanaTokenSecurity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurity) validateResult(formats strfmt.Registry) error {

	if swag.IsZero(m.Result) { // not required
		return nil
	}

	for k := range m.Result {

		if swag.IsZero(m.Result[k]) { // not required
			continue
		}
		if val, ok := m.Result[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurity) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnon key is contract address
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnon
type ResponseWrapperSolanaTokenSecurityResultAnon struct {

	// balance mutable authority
	BalanceMutableAuthority *ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthority `json:"balance_mutable_authority,omitempty"`

	// closable
	Closable *ResponseWrapperSolanaTokenSecurityResultAnonClosable `json:"closable,omitempty"`

	// Contains information about the token creators.
	Creator []*ResponseWrapperSolanaTokenSecurityResultAnonCreatorItems0 `json:"creator"`

	// The default state of newly created accounts. "0" for Uninitialized, "1" for Initialized, "2" for Frozen.(Notice: Uninitialized (0): The token is newly created and not ready for use. It cannot perform any token operations and typically needs to be initialized to become active.
	// Initialized (1): The token is fully ready for use and can engage in normal token transactions. Most token operations require the account to be in this state.
	// Frozen (2): All the account that created whe the token is "frozen" would be locked and prohibited from performing any token transactions or operations, usually for security or compliance reasons, until it is manually unfrozen.)
	DefaultAccountState string `json:"default_account_state,omitempty"`

	// default account state upgradable
	DefaultAccountStateUpgradable *ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradable `json:"default_account_state_upgradable,omitempty"`

	// Dex Info
	Dex []*ResponseWrapperSolanaTokenSecurityResultAnonDexItems0 `json:"dex"`

	// freezable
	Freezable *ResponseWrapperSolanaTokenSecurityResultAnonFreezable `json:"freezable,omitempty"`

	// List of top 10 addresses holding the token and their balances.
	Holders []*ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0 `json:"holders"`

	// List of top10 liquidity holders and their balances of the largest main token(SOL, USDC, USDT) liquidity pool.
	LpHolders []*ResponseWrapperSolanaTokenSecurityResultAnonLpHoldersItems0 `json:"lp_holders"`

	// metadata
	Metadata *ResponseWrapperSolanaTokenSecurityResultAnonMetadata `json:"metadata,omitempty"`

	// metadata mutable
	MetadataMutable *ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutable `json:"metadata_mutable,omitempty"`

	// mintable
	Mintable *ResponseWrapperSolanaTokenSecurityResultAnonMintable `json:"mintable,omitempty"`

	// Indicates whether the token is non-transferable, "1" means non-transferable, "0" means transferable
	NoneTransferable string `json:"none_transferable,omitempty"`

	// transfer fee
	TransferFee *ResponseWrapperSolanaTokenSecurityResultAnonTransferFee `json:"transfer_fee,omitempty"`

	// transfer fee upgradable
	TransferFeeUpgradable *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradable `json:"transfer_fee_upgradable,omitempty"`

	// If there is any external hook in the token programme.(Notice: Hook may block user from trading)
	TransferHook []*ResponseWrapperSolanaTokenSecurityResultAnonTransferHookItems0 `json:"transfer_hook"`

	// transfer hook upgradable
	TransferHookUpgradable *ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradable `json:"transfer_hook_upgradable,omitempty"`

	// If the token is a famous and trustworthy one. "1" means yes.
	TrustedToken int32 `json:"trusted_token,omitempty"`
}

// Validate validates this response wrapper solana token security result anon
func (m *ResponseWrapperSolanaTokenSecurityResultAnon) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBalanceMutableAuthority(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClosable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultAccountStateUpgradable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFreezable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHolders(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLpHolders(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadataMutable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMintable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransferFee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransferFeeUpgradable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransferHook(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransferHookUpgradable(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateBalanceMutableAuthority(formats strfmt.Registry) error {

	if swag.IsZero(m.BalanceMutableAuthority) { // not required
		return nil
	}

	if m.BalanceMutableAuthority != nil {
		if err := m.BalanceMutableAuthority.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("balance_mutable_authority")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateClosable(formats strfmt.Registry) error {

	if swag.IsZero(m.Closable) { // not required
		return nil
	}

	if m.Closable != nil {
		if err := m.Closable.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("closable")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateCreator(formats strfmt.Registry) error {

	if swag.IsZero(m.Creator) { // not required
		return nil
	}

	for i := 0; i < len(m.Creator); i++ {
		if swag.IsZero(m.Creator[i]) { // not required
			continue
		}

		if m.Creator[i] != nil {
			if err := m.Creator[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("creator" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateDefaultAccountStateUpgradable(formats strfmt.Registry) error {

	if swag.IsZero(m.DefaultAccountStateUpgradable) { // not required
		return nil
	}

	if m.DefaultAccountStateUpgradable != nil {
		if err := m.DefaultAccountStateUpgradable.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("default_account_state_upgradable")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateDex(formats strfmt.Registry) error {

	if swag.IsZero(m.Dex) { // not required
		return nil
	}

	for i := 0; i < len(m.Dex); i++ {
		if swag.IsZero(m.Dex[i]) { // not required
			continue
		}

		if m.Dex[i] != nil {
			if err := m.Dex[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dex" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateFreezable(formats strfmt.Registry) error {

	if swag.IsZero(m.Freezable) { // not required
		return nil
	}

	if m.Freezable != nil {
		if err := m.Freezable.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("freezable")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateHolders(formats strfmt.Registry) error {

	if swag.IsZero(m.Holders) { // not required
		return nil
	}

	for i := 0; i < len(m.Holders); i++ {
		if swag.IsZero(m.Holders[i]) { // not required
			continue
		}

		if m.Holders[i] != nil {
			if err := m.Holders[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("holders" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateLpHolders(formats strfmt.Registry) error {

	if swag.IsZero(m.LpHolders) { // not required
		return nil
	}

	for i := 0; i < len(m.LpHolders); i++ {
		if swag.IsZero(m.LpHolders[i]) { // not required
			continue
		}

		if m.LpHolders[i] != nil {
			if err := m.LpHolders[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("lp_holders" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateMetadata(formats strfmt.Registry) error {

	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {
		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateMetadataMutable(formats strfmt.Registry) error {

	if swag.IsZero(m.MetadataMutable) { // not required
		return nil
	}

	if m.MetadataMutable != nil {
		if err := m.MetadataMutable.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata_mutable")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateMintable(formats strfmt.Registry) error {

	if swag.IsZero(m.Mintable) { // not required
		return nil
	}

	if m.Mintable != nil {
		if err := m.Mintable.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mintable")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateTransferFee(formats strfmt.Registry) error {

	if swag.IsZero(m.TransferFee) { // not required
		return nil
	}

	if m.TransferFee != nil {
		if err := m.TransferFee.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transfer_fee")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateTransferFeeUpgradable(formats strfmt.Registry) error {

	if swag.IsZero(m.TransferFeeUpgradable) { // not required
		return nil
	}

	if m.TransferFeeUpgradable != nil {
		if err := m.TransferFeeUpgradable.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transfer_fee_upgradable")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateTransferHook(formats strfmt.Registry) error {

	if swag.IsZero(m.TransferHook) { // not required
		return nil
	}

	for i := 0; i < len(m.TransferHook); i++ {
		if swag.IsZero(m.TransferHook[i]) { // not required
			continue
		}

		if m.TransferHook[i] != nil {
			if err := m.TransferHook[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("transfer_hook" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnon) validateTransferHookUpgradable(formats strfmt.Registry) error {

	if swag.IsZero(m.TransferHookUpgradable) { // not required
		return nil
	}

	if m.TransferHookUpgradable != nil {
		if err := m.TransferHookUpgradable.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transfer_hook_upgradable")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnon) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthority Whether the developer can temper with users token balance.
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthority
type ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthority struct {

	// Information on metadata upgrade authority.
	Authority []*ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthorityAuthorityItems0 `json:"authority"`

	// Status indicator, where "1" means the funtcion is available.
	Status string `json:"status,omitempty"`
}

// Validate validates this response wrapper solana token security result anon balance mutable authority
func (m *ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthority) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthority(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthority) validateAuthority(formats strfmt.Registry) error {

	if swag.IsZero(m.Authority) { // not required
		return nil
	}

	for i := 0; i < len(m.Authority); i++ {
		if swag.IsZero(m.Authority[i]) { // not required
			continue
		}

		if m.Authority[i] != nil {
			if err := m.Authority[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("balance_mutable_authority" + "." + "authority" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthority) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthority) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthority
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthorityAuthorityItems0 response wrapper solana token security result anon balance mutable authority authority items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthorityAuthorityItems0
type ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthorityAuthorityItems0 struct {

	// Address with upgrade authority
	Address string `json:"address,omitempty"`

	// Indicates whether the address is malicious, "1" means yes.
	MaliciousAddress int32 `json:"malicious_address,omitempty"`
}

// Validate validates this response wrapper solana token security result anon balance mutable authority authority items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthorityAuthorityItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthorityAuthorityItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthorityAuthorityItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonBalanceMutableAuthorityAuthorityItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonClosable Whether the developer can close the token programme at any time. If the programme is closed, all the assets would be eliminated.
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonClosable
type ResponseWrapperSolanaTokenSecurityResultAnonClosable struct {

	// Information on metadata upgrade authority.
	Authority []*ResponseWrapperSolanaTokenSecurityResultAnonClosableAuthorityItems0 `json:"authority"`

	// Status indicator, where "1" means the funtcion is available.
	Status string `json:"status,omitempty"`
}

// Validate validates this response wrapper solana token security result anon closable
func (m *ResponseWrapperSolanaTokenSecurityResultAnonClosable) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthority(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonClosable) validateAuthority(formats strfmt.Registry) error {

	if swag.IsZero(m.Authority) { // not required
		return nil
	}

	for i := 0; i < len(m.Authority); i++ {
		if swag.IsZero(m.Authority[i]) { // not required
			continue
		}

		if m.Authority[i] != nil {
			if err := m.Authority[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("closable" + "." + "authority" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonClosable) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonClosable) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonClosable
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonClosableAuthorityItems0 response wrapper solana token security result anon closable authority items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonClosableAuthorityItems0
type ResponseWrapperSolanaTokenSecurityResultAnonClosableAuthorityItems0 struct {

	// Address with upgrade authority
	Address string `json:"address,omitempty"`

	// Indicates whether the address is malicious, "1" means yes.
	MaliciousAddress int32 `json:"malicious_address,omitempty"`
}

// Validate validates this response wrapper solana token security result anon closable authority items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonClosableAuthorityItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonClosableAuthorityItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonClosableAuthorityItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonClosableAuthorityItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonCreatorItems0 response wrapper solana token security result anon creator items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonCreatorItems0
type ResponseWrapperSolanaTokenSecurityResultAnonCreatorItems0 struct {

	// Address of the creator.
	Address string `json:"address,omitempty"`

	// Indicates whether the address is malicious, "1" means yes.
	MaliciousAddress int32 `json:"malicious_address,omitempty"`
}

// Validate validates this response wrapper solana token security result anon creator items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonCreatorItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonCreatorItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonCreatorItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonCreatorItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradable whether the default account state can be upgradable.
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradable
type ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradable struct {

	// Information on metadata upgrade authority.
	Authority []*ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradableAuthorityItems0 `json:"authority"`

	// Status indicator, where "1" means the funtcion is available.
	Status string `json:"status,omitempty"`
}

// Validate validates this response wrapper solana token security result anon default account state upgradable
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradable) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthority(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradable) validateAuthority(formats strfmt.Registry) error {

	if swag.IsZero(m.Authority) { // not required
		return nil
	}

	for i := 0; i < len(m.Authority); i++ {
		if swag.IsZero(m.Authority[i]) { // not required
			continue
		}

		if m.Authority[i] != nil {
			if err := m.Authority[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("default_account_state_upgradable" + "." + "authority" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradable) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradable) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradable
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradableAuthorityItems0 response wrapper solana token security result anon default account state upgradable authority items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradableAuthorityItems0
type ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradableAuthorityItems0 struct {

	// Address with upgrade authority
	Address string `json:"address,omitempty"`

	// Indicates whether the address is malicious, "1" means yes.
	MaliciousAddress int32 `json:"malicious_address,omitempty"`
}

// Validate validates this response wrapper solana token security result anon default account state upgradable authority items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradableAuthorityItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradableAuthorityItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradableAuthorityItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonDefaultAccountStateUpgradableAuthorityItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonDexItems0 response wrapper solana token security result anon dex items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonDexItems0
type ResponseWrapperSolanaTokenSecurityResultAnonDexItems0 struct {

	// Percentage of burned LP
	BurnPercent float64 `json:"burn_percent,omitempty"`

	// day
	Day *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Day `json:"day,omitempty"`

	// Name of the DEX.
	DexName string `json:"dex_name,omitempty"`

	// Transaction fee rate.
	FeeRate string `json:"fee_rate,omitempty"`

	// Address of the liquidity pool.
	ID string `json:"id,omitempty"`

	// Total amount of liquidity provider tokens, only shown when type is "standard"
	LpAmount string `json:"lp_amount,omitempty"`

	// month
	Month *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Month `json:"month,omitempty"`

	// The epoch when trading is opened.
	OpenTime string `json:"open_time,omitempty"`

	// Current price (Unitless, count by two tokens in the pool).
	Price string `json:"price,omitempty"`

	// Total value locked (TVL) in the liquidity pool.
	Tvl string `json:"tvl,omitempty"`

	// Type of the DEX, could be "standard" or "concentrated".
	Type string `json:"type,omitempty"`

	// week
	Week *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Week `json:"week,omitempty"`
}

// Validate validates this response wrapper solana token security result anon dex items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDay(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWeek(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0) validateDay(formats strfmt.Registry) error {

	if swag.IsZero(m.Day) { // not required
		return nil
	}

	if m.Day != nil {
		if err := m.Day.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("day")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0) validateMonth(formats strfmt.Registry) error {

	if swag.IsZero(m.Month) { // not required
		return nil
	}

	if m.Month != nil {
		if err := m.Month.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("month")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0) validateWeek(formats strfmt.Registry) error {

	if swag.IsZero(m.Week) { // not required
		return nil
	}

	if m.Week != nil {
		if err := m.Week.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("week")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonDexItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Day Trading data for last day.
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Day
type ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Day struct {

	// Maximum price during this period.
	PriceMax string `json:"price_max,omitempty"`

	// Minimum price during this period.
	PriceMin string `json:"price_min,omitempty"`

	// The volume of transactions during this period.
	Volume string `json:"volume,omitempty"`
}

// Validate validates this response wrapper solana token security result anon dex items0 day
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Day) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Day) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Day) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Day
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Month Trading data for last month.
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Month
type ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Month struct {

	// Maximum price during this period.
	PriceMax string `json:"price_max,omitempty"`

	// Minimum price during this period.
	PriceMin string `json:"price_min,omitempty"`

	// The volume of transactions during this period.
	Volume string `json:"volume,omitempty"`
}

// Validate validates this response wrapper solana token security result anon dex items0 month
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Month) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Month) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Month) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Month
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Week Trading data for last week.
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Week
type ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Week struct {

	// Maximum price during this period.
	PriceMax string `json:"price_max,omitempty"`

	// Minimum price during this period.
	PriceMin string `json:"price_min,omitempty"`

	// The volume of transactions during this period.
	Volume string `json:"volume,omitempty"`
}

// Validate validates this response wrapper solana token security result anon dex items0 week
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Week) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Week) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Week) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonDexItems0Week
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonFreezable Whether the developer can block any other users from trading.
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonFreezable
type ResponseWrapperSolanaTokenSecurityResultAnonFreezable struct {

	// Information on metadata upgrade authority.
	Authority []*ResponseWrapperSolanaTokenSecurityResultAnonFreezableAuthorityItems0 `json:"authority"`

	// Status indicator, where "1" means the funtcion is available.
	Status string `json:"status,omitempty"`
}

// Validate validates this response wrapper solana token security result anon freezable
func (m *ResponseWrapperSolanaTokenSecurityResultAnonFreezable) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthority(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonFreezable) validateAuthority(formats strfmt.Registry) error {

	if swag.IsZero(m.Authority) { // not required
		return nil
	}

	for i := 0; i < len(m.Authority); i++ {
		if swag.IsZero(m.Authority[i]) { // not required
			continue
		}

		if m.Authority[i] != nil {
			if err := m.Authority[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("freezable" + "." + "authority" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonFreezable) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonFreezable) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonFreezable
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonFreezableAuthorityItems0 response wrapper solana token security result anon freezable authority items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonFreezableAuthorityItems0
type ResponseWrapperSolanaTokenSecurityResultAnonFreezableAuthorityItems0 struct {

	// Address with upgrade authority
	Address string `json:"address,omitempty"`

	// Indicates whether the address is malicious, "1" means yes.
	MaliciousAddress int32 `json:"malicious_address,omitempty"`
}

// Validate validates this response wrapper solana token security result anon freezable authority items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonFreezableAuthorityItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonFreezableAuthorityItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonFreezableAuthorityItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonFreezableAuthorityItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0 response wrapper solana token security result anon holders items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0
type ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0 struct {

	// Amount of tokens held.
	Balance string `json:"balance,omitempty"`

	// It describes whether the tokens owned by the holder are locked "1" means true; "0" means false;
	// (3) 'tag' describes the address's public tag. Example:Burn (Notice:About "locked":We only support the token lock addresses or black hole addresses that we have included. )
	IsLocked int32 `json:"is_locked,omitempty"`

	// It is an array, decribes lock position info of this holder, only shows when "locked":1. This Array may contain multiple objects for multiple locking info. (Notice:When "locked":0, or lock address is a black hole address,  "locked_detail" will be no return.)
	LockedDetail []*ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0LockedDetailItems0 `json:"locked_detail"`

	// Percentage of total supply held.
	Percent string `json:"percent,omitempty"`

	// Tag information of the holder.
	Tag string `json:"tag,omitempty"`

	// Address of the holder.
	TokenAccount string `json:"token_account,omitempty"`
}

// Validate validates this response wrapper solana token security result anon holders items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLockedDetail(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0) validateLockedDetail(formats strfmt.Registry) error {

	if swag.IsZero(m.LockedDetail) { // not required
		return nil
	}

	for i := 0; i < len(m.LockedDetail); i++ {
		if swag.IsZero(m.LockedDetail[i]) { // not required
			continue
		}

		if m.LockedDetail[i] != nil {
			if err := m.LockedDetail[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("locked_detail" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0LockedDetailItems0 response wrapper solana token security result anon holders items0 locked detail items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0LockedDetailItems0
type ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0LockedDetailItems0 struct {

	// "amount" describes the number of token locked
	Amount string `json:"amount,omitempty"`

	// "end_time" describes when the token will be unlocked
	EndTime string `json:"end_time,omitempty"`

	// "opt_time" describes when the token was locked
	OptTime string `json:"opt_time,omitempty"`
}

// Validate validates this response wrapper solana token security result anon holders items0 locked detail items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0LockedDetailItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0LockedDetailItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0LockedDetailItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonHoldersItems0LockedDetailItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonLpHoldersItems0 response wrapper solana token security result anon lp holders items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonLpHoldersItems0
type ResponseWrapperSolanaTokenSecurityResultAnonLpHoldersItems0 struct {

	// Amount of tokens held.
	Balance string `json:"balance,omitempty"`

	// Percentage of total supply held.
	Percent string `json:"percent,omitempty"`

	// Tag information of the holder.
	Tag string `json:"tag,omitempty"`

	// Address of the holder.
	TokenAccount string `json:"token_account,omitempty"`
}

// Validate validates this response wrapper solana token security result anon lp holders items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonLpHoldersItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonLpHoldersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonLpHoldersItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonLpHoldersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonMetadata Contains the metadata information of the token.
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonMetadata
type ResponseWrapperSolanaTokenSecurityResultAnonMetadata struct {

	// Description of the token.
	Description string `json:"description,omitempty"`

	// Name of the token.
	Name string `json:"name,omitempty"`

	// Symbol of the token.
	Symbol string `json:"symbol,omitempty"`

	// URI pointing to related token information.
	URI string `json:"uri,omitempty"`
}

// Validate validates this response wrapper solana token security result anon metadata
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMetadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMetadata) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutable Whether the metadata is mutable.
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutable
type ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutable struct {

	// Information on metadata upgrade authority.
	MetadataUpgradeAuthority []*ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutableMetadataUpgradeAuthorityItems0 `json:"metadata_upgrade_authority"`

	// Status indicator, where "1" means the funtcion is available.
	Status string `json:"status,omitempty"`
}

// Validate validates this response wrapper solana token security result anon metadata mutable
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutable) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMetadataUpgradeAuthority(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutable) validateMetadataUpgradeAuthority(formats strfmt.Registry) error {

	if swag.IsZero(m.MetadataUpgradeAuthority) { // not required
		return nil
	}

	for i := 0; i < len(m.MetadataUpgradeAuthority); i++ {
		if swag.IsZero(m.MetadataUpgradeAuthority[i]) { // not required
			continue
		}

		if m.MetadataUpgradeAuthority[i] != nil {
			if err := m.MetadataUpgradeAuthority[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metadata_mutable" + "." + "metadata_upgrade_authority" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutable) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutable) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutable
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutableMetadataUpgradeAuthorityItems0 response wrapper solana token security result anon metadata mutable metadata upgrade authority items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutableMetadataUpgradeAuthorityItems0
type ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutableMetadataUpgradeAuthorityItems0 struct {

	// Address with upgrade authority
	Address string `json:"address,omitempty"`

	// Indicates whether the address is malicious, "1" means yes.
	MaliciousAddress int32 `json:"malicious_address,omitempty"`
}

// Validate validates this response wrapper solana token security result anon metadata mutable metadata upgrade authority items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutableMetadataUpgradeAuthorityItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutableMetadataUpgradeAuthorityItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutableMetadataUpgradeAuthorityItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonMetadataMutableMetadataUpgradeAuthorityItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonMintable Whether the token is mintable.
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonMintable
type ResponseWrapperSolanaTokenSecurityResultAnonMintable struct {

	// Information on metadata upgrade authority.
	Authority []*ResponseWrapperSolanaTokenSecurityResultAnonMintableAuthorityItems0 `json:"authority"`

	// Status indicator, where "1" means the funtcion is available.
	Status string `json:"status,omitempty"`
}

// Validate validates this response wrapper solana token security result anon mintable
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMintable) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthority(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonMintable) validateAuthority(formats strfmt.Registry) error {

	if swag.IsZero(m.Authority) { // not required
		return nil
	}

	for i := 0; i < len(m.Authority); i++ {
		if swag.IsZero(m.Authority[i]) { // not required
			continue
		}

		if m.Authority[i] != nil {
			if err := m.Authority[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mintable" + "." + "authority" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMintable) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMintable) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonMintable
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonMintableAuthorityItems0 response wrapper solana token security result anon mintable authority items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonMintableAuthorityItems0
type ResponseWrapperSolanaTokenSecurityResultAnonMintableAuthorityItems0 struct {

	// Address with upgrade authority
	Address string `json:"address,omitempty"`

	// Indicates whether the address is malicious, "1" means yes.
	MaliciousAddress int32 `json:"malicious_address,omitempty"`
}

// Validate validates this response wrapper solana token security result anon mintable authority items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMintableAuthorityItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMintableAuthorityItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonMintableAuthorityItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonMintableAuthorityItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonTransferFee Configuration information for transfer fees.(Notice: "Scheduled Fee" would take effect and turn into "Current Fee" when the epoch is reached.)
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonTransferFee
type ResponseWrapperSolanaTokenSecurityResultAnonTransferFee struct {

	// current fee rate
	CurrentFeeRate *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeCurrentFeeRate `json:"current_fee_rate,omitempty"`

	// Scheduled changes to transfer fee rates.
	ScheduledFeeRate []*ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeScheduledFeeRateItems0 `json:"scheduled_fee_rate"`
}

// Validate validates this response wrapper solana token security result anon transfer fee
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFee) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCurrentFeeRate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScheduledFeeRate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFee) validateCurrentFeeRate(formats strfmt.Registry) error {

	if swag.IsZero(m.CurrentFeeRate) { // not required
		return nil
	}

	if m.CurrentFeeRate != nil {
		if err := m.CurrentFeeRate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transfer_fee" + "." + "current_fee_rate")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFee) validateScheduledFeeRate(formats strfmt.Registry) error {

	if swag.IsZero(m.ScheduledFeeRate) { // not required
		return nil
	}

	for i := 0; i < len(m.ScheduledFeeRate); i++ {
		if swag.IsZero(m.ScheduledFeeRate[i]) { // not required
			continue
		}

		if m.ScheduledFeeRate[i] != nil {
			if err := m.ScheduledFeeRate[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("transfer_fee" + "." + "scheduled_fee_rate" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFee) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFee) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonTransferFee
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeCurrentFeeRate Currently effective transfer fee rate.
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeCurrentFeeRate
type ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeCurrentFeeRate struct {

	// Fee rate (expressed as a ratio, e.g., 0.02 means 2%)
	FeeRate string `json:"fee_rate,omitempty"`

	// Maximum fee amount for a single transaction.
	MaximumFee string `json:"maximum_fee,omitempty"`
}

// Validate validates this response wrapper solana token security result anon transfer fee current fee rate
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeCurrentFeeRate) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeCurrentFeeRate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeCurrentFeeRate) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeCurrentFeeRate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeScheduledFeeRateItems0 response wrapper solana token security result anon transfer fee scheduled fee rate items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeScheduledFeeRateItems0
type ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeScheduledFeeRateItems0 struct {

	// The epoch at which the fee rate will take effect.
	Epoch string `json:"epoch,omitempty"`

	// Fee rate (expressed as a ratio, e.g., 0.02 means 2%)
	FeeRate string `json:"fee_rate,omitempty"`

	// Maximum fee amount for a single transaction.
	MaximumFee string `json:"maximum_fee,omitempty"`
}

// Validate validates this response wrapper solana token security result anon transfer fee scheduled fee rate items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeScheduledFeeRateItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeScheduledFeeRateItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeScheduledFeeRateItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeScheduledFeeRateItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradable Whether the transfer fee of the token can be upgraded
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradable
type ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradable struct {

	// Information on metadata upgrade authority.
	Authority []*ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradableAuthorityItems0 `json:"authority"`

	// Status indicator, where "1" means the funtcion is available.
	Status string `json:"status,omitempty"`
}

// Validate validates this response wrapper solana token security result anon transfer fee upgradable
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradable) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthority(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradable) validateAuthority(formats strfmt.Registry) error {

	if swag.IsZero(m.Authority) { // not required
		return nil
	}

	for i := 0; i < len(m.Authority); i++ {
		if swag.IsZero(m.Authority[i]) { // not required
			continue
		}

		if m.Authority[i] != nil {
			if err := m.Authority[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("transfer_fee_upgradable" + "." + "authority" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradable) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradable) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradable
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradableAuthorityItems0 response wrapper solana token security result anon transfer fee upgradable authority items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradableAuthorityItems0
type ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradableAuthorityItems0 struct {

	// Address with upgrade authority
	Address string `json:"address,omitempty"`

	// Indicates whether the address is malicious, "1" means yes.
	MaliciousAddress int32 `json:"malicious_address,omitempty"`
}

// Validate validates this response wrapper solana token security result anon transfer fee upgradable authority items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradableAuthorityItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradableAuthorityItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradableAuthorityItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonTransferFeeUpgradableAuthorityItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonTransferHookItems0 response wrapper solana token security result anon transfer hook items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonTransferHookItems0
type ResponseWrapperSolanaTokenSecurityResultAnonTransferHookItems0 struct {

	// Address of the hook.
	Address string `json:"address,omitempty"`

	// Indicates whether the address is malicious, "1" means yes.
	MaliciousAddress int32 `json:"malicious_address,omitempty"`
}

// Validate validates this response wrapper solana token security result anon transfer hook items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferHookItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferHookItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferHookItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonTransferHookItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradable Whether the transfer hook is upgradable.
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradable
type ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradable struct {

	// Information on metadata upgrade authority.
	Authority []*ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradableAuthorityItems0 `json:"authority"`

	// Status indicator, where "1" means the funtcion is available.
	Status string `json:"status,omitempty"`
}

// Validate validates this response wrapper solana token security result anon transfer hook upgradable
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradable) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthority(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradable) validateAuthority(formats strfmt.Registry) error {

	if swag.IsZero(m.Authority) { // not required
		return nil
	}

	for i := 0; i < len(m.Authority); i++ {
		if swag.IsZero(m.Authority[i]) { // not required
			continue
		}

		if m.Authority[i] != nil {
			if err := m.Authority[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("transfer_hook_upgradable" + "." + "authority" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradable) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradable) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradable
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradableAuthorityItems0 response wrapper solana token security result anon transfer hook upgradable authority items0
//
// swagger:model ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradableAuthorityItems0
type ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradableAuthorityItems0 struct {

	// Address with upgrade authority
	Address string `json:"address,omitempty"`

	// Indicates whether the address is malicious, "1" means yes.
	MaliciousAddress int32 `json:"malicious_address,omitempty"`
}

// Validate validates this response wrapper solana token security result anon transfer hook upgradable authority items0
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradableAuthorityItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradableAuthorityItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradableAuthorityItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperSolanaTokenSecurityResultAnonTransferHookUpgradableAuthorityItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
