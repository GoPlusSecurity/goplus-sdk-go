// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ResponseWrapperGetNftInfo ResponseWrapperGetNftInfo
//
// swagger:model ResponseWrapperGetNftInfo
type ResponseWrapperGetNftInfo struct {

	// Code 1: Success
	Code int32 `json:"code,omitempty"`

	// Response message
	Message string `json:"message,omitempty"`

	// result
	Result *ResponseWrapperGetNftInfoResult `json:"result,omitempty"`
}

// Validate validates this response wrapper get nft info
func (m *ResponseWrapperGetNftInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperGetNftInfo) validateResult(formats strfmt.Registry) error {

	if swag.IsZero(m.Result) { // not required
		return nil
	}

	if m.Result != nil {
		if err := m.Result.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfo) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperGetNftInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperGetNftInfoResult Response result
//
// swagger:model ResponseWrapperGetNftInfoResult
type ResponseWrapperGetNftInfoResult struct {

	// It describes the average price of the NFT in 24h.
	AveragePrice24h float64 `json:"average_price_24h,omitempty"`

	// It describes the number of blocks created for the NFT.
	// Return "null" means that we didn't find the number of blocks created for the NFT.
	CreateBlockNumber int64 `json:"create_block_number,omitempty"`

	// It describes the creator address of the NFT.
	// Example: "creator_address": "0x1ee0af784b96bb55ece98c9b15675726b0da1b6b";
	// Return "null" means that we didn't find the creator address.
	CreatorAddress string `json:"creator_address,omitempty"`

	// It describes the discord url of the NFT.
	// Return "null" means there is no discord url or didn't find the discord url.
	DiscordURL string `json:"discord_url,omitempty"`

	// It describes the github url of the NFT.
	// Return "null" means there is no github url or didn't find the github url.
	GithubURL string `json:"github_url,omitempty"`

	// It describes the highest price of the NFT.
	HighestPrice float64 `json:"highest_price,omitempty"`

	// It describes the lowest price of the NFT in 24h.
	LowestPrice24h float64 `json:"lowest_price_24h,omitempty"`

	// It describes whether this NFT has performed malicious behaviors.
	// "1" means true;
	// "0" means false.(Notice:Malicious behaviors include random additions, blacklist abuse, falsified transactions, and other high-risk behaviors. Interacting with NFTs flagged as Malicious may contain a high level of risk)
	MaliciousNftContract int32 `json:"malicious_nft_contract,omitempty"`

	// It describes the medium url of the NFT.
	// Return "null" means there is no medium url or didn't find the medium url.
	MediumURL string `json:"medium_url,omitempty"`

	// metadata_frozen
	MetadataFrozen int32 `json:"metadata_frozen,omitempty"`

	// It describes the introduction of the NFT.
	// Return "null" means there is no description of the NFT.
	NftDescription string `json:"nft_description,omitempty"`

	// It describes the ERC protocol of the NFT.
	// Example: "nft_erc": "erc721"
	NftErc string `json:"nft_erc,omitempty"`

	// It describes the numbers of the NFT.
	NftItems int64 `json:"nft_items,omitempty"`

	// nft_name
	NftName string `json:"nft_name,omitempty"`

	// It describes whether this contract is open source.
	// "1" means true;
	// "0" means false.(Notice:Un-open-sourced contracts may hide various unknown mechanisms and are extremely risky. When the contract is not open source, we will not be able to detect other risk items.)
	NftOpenSource int32 `json:"nft_open_source,omitempty"`

	// It describes the holders of the NFT.
	NftOwnerNumber int64 `json:"nft_owner_number,omitempty"`

	// It describes whether this NFT contract has a proxy contract.
	// "1" means true;
	// "0" means false;
	// "Null" means unknown.(Notice:(1) When "is_open_source": "0", it will return "null".
	// (2) Most Proxy contracts are accompanied by modifiable implementation contracts, and implementation contracts may contain significant potential risk.)
	NftProxy int32 `json:"nft_proxy,omitempty"`

	// nft_symbol
	NftSymbol string `json:"nft_symbol,omitempty"`

	// It describes whether the NFT is verified.
	// "1" means that the NFT is verified;
	// "0" means that we did not find any information about whether the NFT is verified.
	NftVerified int32 `json:"nft_verified,omitempty"`

	// It describes whether this NFT owner can bypass the maximum amount of minting specified in the contract, and continue to mint NFTs beyond this limit.
	// "1" means true;
	// "0" means false;
	// "Null" means unknown.(Notice:Oversupply minting refers to the existence of a special mint method in the NFT contract - the owner can bypass the maximum amount of minting specified in the contract, and continue to mint NFTs beyond this limit.)
	OversupplyMinting int32 `json:"oversupply_minting,omitempty"`

	// privileged burn
	PrivilegedBurn *ResponseWrapperGetNftInfoResultPrivilegedBurn `json:"privileged_burn,omitempty"`

	// privileged minting
	PrivilegedMinting *ResponseWrapperGetNftInfoResultPrivilegedMinting `json:"privileged_minting,omitempty"`

	// red check mark
	RedCheckMark int32 `json:"red_check_mark,omitempty"`

	// It describes whether the NFT contract can restrict the approval, resulting in NFT can not be traded on the NFT DEX.
	// "1" means true;
	// "0" means false;
	// "Null" means unknown.(Notice:If this risk exists, it means that users will not be able to trade the NFT on the exchange and only privileged users in the whitelist will be able to trade normally.)
	RestrictedApproval int32 `json:"restricted_approval,omitempty"`

	// It describes the sales of the NFT in 24h.
	Sales24h float64 `json:"sales_24h,omitempty"`

	// It describes the info of other NFTs with duplicate name and symbol.
	SameNfts []*ResponseWrapperGetNftInfoResultSameNftsItems0 `json:"same_nfts"`

	// self destruct
	SelfDestruct *ResponseWrapperGetNftInfoResultSelfDestruct `json:"self_destruct,omitempty"`

	// It describes the telegram url of the NFT.
	// Return "null" means there is no telegram url or didn't find the telegram url.
	TelegramURL string `json:"telegram_url,omitempty"`

	// token_id
	TokenID string `json:"token_id,omitempty"`

	// token_owner
	TokenOwner string `json:"token_owner,omitempty"`

	// It describes the total volume of the NFT.
	TotalVolume float64 `json:"total_volume,omitempty"`

	// It describes the trading volume of the NFT in 24h.
	TradedVolume24h float64 `json:"traded_volume_24h,omitempty"`

	// transfer without approval
	TransferWithoutApproval *ResponseWrapperGetNftInfoResultTransferWithoutApproval `json:"transfer_without_approval,omitempty"`

	// It describes whether the NFT is a famous and trustworthy one.
	// "1" means true;
	// Return "null" means no result.(Notice:(1) Only "trust_list": "1" means it is a famous and trustworthy NFT.
	// (2) Return "null" doesn't mean it is risky.Th)
	TrustList int32 `json:"trust_list,omitempty"`

	// It describes the twitter url of the NFT.
	// Return "null" means there is no twitter url or didn't find the twitter url.
	TwitterURL string `json:"twitter_url,omitempty"`

	// It describes the website url of the NFT.
	// Return "null" means there is no website url or didn't find the website url.
	WebsiteURL string `json:"website_url,omitempty"`
}

// Validate validates this response wrapper get nft info result
func (m *ResponseWrapperGetNftInfoResult) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePrivilegedBurn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivilegedMinting(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSameNfts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfDestruct(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransferWithoutApproval(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperGetNftInfoResult) validatePrivilegedBurn(formats strfmt.Registry) error {

	if swag.IsZero(m.PrivilegedBurn) { // not required
		return nil
	}

	if m.PrivilegedBurn != nil {
		if err := m.PrivilegedBurn.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result" + "." + "privileged_burn")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperGetNftInfoResult) validatePrivilegedMinting(formats strfmt.Registry) error {

	if swag.IsZero(m.PrivilegedMinting) { // not required
		return nil
	}

	if m.PrivilegedMinting != nil {
		if err := m.PrivilegedMinting.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result" + "." + "privileged_minting")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperGetNftInfoResult) validateSameNfts(formats strfmt.Registry) error {

	if swag.IsZero(m.SameNfts) { // not required
		return nil
	}

	for i := 0; i < len(m.SameNfts); i++ {
		if swag.IsZero(m.SameNfts[i]) { // not required
			continue
		}

		if m.SameNfts[i] != nil {
			if err := m.SameNfts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("result" + "." + "same_nfts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ResponseWrapperGetNftInfoResult) validateSelfDestruct(formats strfmt.Registry) error {

	if swag.IsZero(m.SelfDestruct) { // not required
		return nil
	}

	if m.SelfDestruct != nil {
		if err := m.SelfDestruct.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result" + "." + "self_destruct")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperGetNftInfoResult) validateTransferWithoutApproval(formats strfmt.Registry) error {

	if swag.IsZero(m.TransferWithoutApproval) { // not required
		return nil
	}

	if m.TransferWithoutApproval != nil {
		if err := m.TransferWithoutApproval.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result" + "." + "transfer_without_approval")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfoResult) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfoResult) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperGetNftInfoResult
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperGetNftInfoResultPrivilegedBurn It describes whether the NFT owner can burn others NFT.(Notice:Privileged_burn means that the owner can burn others' NFTs directly through the method.)
//
// swagger:model ResponseWrapperGetNftInfoResultPrivilegedBurn
type ResponseWrapperGetNftInfoResultPrivilegedBurn struct {

	// Owner_address describes the owner address.
	// null: the owner address cannot be fetched.
	OwnerAddress string `json:"owner_address,omitempty"`

	// "blackhole" : the owner is a blackhole address.
	// "contract" : the owner is a contract.
	// "eoa" : the owner is a common address (eoa).
	// "multi-address": the owner is an array/list.
	// null: the address is not detected.
	OwnerType string `json:"owner_type,omitempty"`

	// The "value" describes the status of the risk.
	// null: the contract is not open source or there is a proxy, it is not possible to detect whether the risk exists. -1: the risk is detected but the ownership give up. If the detection of a code vulnerability, it can also be considered risk-free.
	// 0: the risk is not detected.
	// 1: the risk is detected, and the owner address is a common address (EOA), then it can be said that there is a clear risk.
	// 2: The risk is detected, but the owner address is a contract address, the risk is not significant.
	// 3: The risk is detected, but the owner address is not detectable / or an array.
	//
	Value int32 `json:"value,omitempty"`
}

// Validate validates this response wrapper get nft info result privileged burn
func (m *ResponseWrapperGetNftInfoResultPrivilegedBurn) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfoResultPrivilegedBurn) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfoResultPrivilegedBurn) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperGetNftInfoResultPrivilegedBurn
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperGetNftInfoResultPrivilegedMinting It describes whether the NFT contract has  minting methods which can only be triggered by an address with special privileges.
// (Notice:Some minting methods can only be triggered by an address with special privileges. Generally speaking, these are usually for the owner to mint.)
//
// swagger:model ResponseWrapperGetNftInfoResultPrivilegedMinting
type ResponseWrapperGetNftInfoResultPrivilegedMinting struct {

	// Owner_address describes the owner address.
	// null: the owner address cannot be fetched.
	OwnerAddress string `json:"owner_address,omitempty"`

	// "blackhole" : the owner is a blackhole address.
	// "contract" : the owner is a contract.
	// "eoa" : the owner is a common address (eoa).
	// "multi-address": the owner is an array/list.
	// null: the address is not detected.
	OwnerType string `json:"owner_type,omitempty"`

	// The "value" describes the status of the risk.
	// null: the contract is not open source or there is a proxy, it is not possible to detect whether the risk exists. -1: the risk is detected but the ownership give up. If the detection of a code vulnerability, it can also be considered risk-free.
	// 0: the risk is not detected.
	// 1: the risk is detected, and the owner address is a common address (EOA), then it can be said that there is a clear risk.
	// 2: The risk is detected, but the owner address is a contract address, the risk is not significant.
	// 3: The risk is detected, but the owner address is not detectable / or an array.
	//
	Value int32 `json:"value,omitempty"`
}

// Validate validates this response wrapper get nft info result privileged minting
func (m *ResponseWrapperGetNftInfoResultPrivilegedMinting) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfoResultPrivilegedMinting) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfoResultPrivilegedMinting) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperGetNftInfoResultPrivilegedMinting
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperGetNftInfoResultSameNftsItems0 response wrapper get nft info result same nfts items0
//
// swagger:model ResponseWrapperGetNftInfoResultSameNftsItems0
type ResponseWrapperGetNftInfoResultSameNftsItems0 struct {

	// describes the number of blocks created for the NFT.
	// Return "null" means no NFTs with duplicate name and symbol.
	CreateBlockNumber int64 `json:"create_block_number,omitempty"`

	// It describes the address of the NFTs;
	NftAddress string `json:"nft_address,omitempty"`

	// It describes the name of the NFT;
	NftName string `json:"nft_name,omitempty"`

	// It describes the holders of the NFT;
	NftOwnerNumber int64 `json:"nft_owner_number,omitempty"`

	// It describes the symbol of the NFT;
	NftSymbol string `json:"nft_symbol,omitempty"`
}

// Validate validates this response wrapper get nft info result same nfts items0
func (m *ResponseWrapperGetNftInfoResultSameNftsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfoResultSameNftsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfoResultSameNftsItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperGetNftInfoResultSameNftsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperGetNftInfoResultSelfDestruct { value: owner_address: owner_type }It describes whether this NFT contract can self destruct.
// (Notice:When the self-destruct function is triggered, this contract will be destroyed, all functions will be unavailable, and all related assets will be erased.)
//
// swagger:model ResponseWrapperGetNftInfoResultSelfDestruct
type ResponseWrapperGetNftInfoResultSelfDestruct struct {

	// Owner_address describes the owner address.
	// null: the owner address cannot be fetched.
	OwnerAddress string `json:"owner_address,omitempty"`

	// "blackhole" : the owner is a blackhole address.
	// "contract" : the owner is a contract.
	// "eoa" : the owner is a common address (eoa).
	// "multi-address": the owner is an array/list.
	// null: the address is not detected.
	OwnerType string `json:"owner_type,omitempty"`

	// The "value" describes the status of the risk.
	// null: the contract is not open source or there is a proxy, it is not possible to detect whether the risk exists. -1: the risk is detected but the ownership give up. If the detection of a code vulnerability, it can also be considered risk-free.
	// 0: the risk is not detected.
	// 1: the risk is detected, and the owner address is a common address (EOA), then it can be said that there is a clear risk.
	// 2: The risk is detected, but the owner address is a contract address, the risk is not significant.
	// 3: The risk is detected, but the owner address is not detectable / or an array.
	//
	Value int32 `json:"value,omitempty"`
}

// Validate validates this response wrapper get nft info result self destruct
func (m *ResponseWrapperGetNftInfoResultSelfDestruct) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfoResultSelfDestruct) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfoResultSelfDestruct) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperGetNftInfoResultSelfDestruct
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperGetNftInfoResultTransferWithoutApproval It describes whether the NFT owner can transfer NFT without approval.(Notice:Transfer_without_approval generally means the scammer does not need to get approvals to transfer another address's NFT.
// One typical example is sleep_minting. Sleep_minting means that the scammer will first add the NFT to a well-known wallet address and then retrieve the NFT. After the value of the NFT has appreciated , it will be put back on the market.)
//
// swagger:model ResponseWrapperGetNftInfoResultTransferWithoutApproval
type ResponseWrapperGetNftInfoResultTransferWithoutApproval struct {

	// Owner_address describes the owner address.
	// null: the owner address cannot be fetched.
	OwnerAddress string `json:"owner_address,omitempty"`

	// "blackhole" : the owner is a blackhole address.
	// "contract" : the owner is a contract.
	// "eoa" : the owner is a common address (eoa).
	// "multi-address": the owner is an array/list.
	// null: the address is not detected.
	OwnerType string `json:"owner_type,omitempty"`

	// The "value" describes the status of the risk.
	// null: the contract is not open source or there is a proxy, it is not possible to detect whether the risk exists. -1: the risk is detected but the ownership give up. If the detection of a code vulnerability, it can also be considered risk-free.
	// 0: the risk is not detected.
	// 1: the risk is detected, and the owner address is a common address (EOA), then it can be said that there is a clear risk.
	// 2: The risk is detected, but the owner address is a contract address, the risk is not significant.
	// 3: The risk is detected, but the owner address is not detectable / or an array.
	//
	Value int32 `json:"value,omitempty"`
}

// Validate validates this response wrapper get nft info result transfer without approval
func (m *ResponseWrapperGetNftInfoResultTransferWithoutApproval) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfoResultTransferWithoutApproval) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperGetNftInfoResultTransferWithoutApproval) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperGetNftInfoResultTransferWithoutApproval
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
